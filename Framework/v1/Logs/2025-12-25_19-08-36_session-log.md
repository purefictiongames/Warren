# Session Log: 2025-12-25

## Overview

This session focused on building a modular Roblox game framework using Rojo, establishing architectural patterns, and setting up package management with Wally.

---

## 1. Initial Setup & Codebase Exploration

- User tested Claude CLI installation from web chat
- Explored the LibPureFiction Roblox game framework built with Rojo
- Framework located at `/mnt/c/Dev/LibPureFiction/Framework/v1`

---

## 2. Architecture Problem: Rojo + Models

### The Problem
Assets like MarshmallowBag are **Models** in Roblox Studio, not folders. Rojo by default treats filesystem folders as Folders.

### The Solution
Use `init.meta.json` to define the className for Rojo to properly instantiate:

```json
{
  "className": "Model"
}
```

This tells Rojo to create a Model instance instead of a Folder.

---

## 3. Dispenser Module Development

### Design Decisions
- Generic naming: "Dispenser" instead of "MarshmallowBag"
- All dispensers work the same - only need 2 pieces of data:
  - **Capacity**: How many items it holds
  - **DispenseItem**: What item type to dispense (references Templates folder)

### File Structure Created

```
src/Assets/Dispenser/
├── init.meta.json              # className: "Model"
├── ReplicatedStorage/
│   └── ModuleScript.lua        # Dispenser class (shared)
└── ServerScriptService/
    └── Script.server.lua       # ProximityPrompt handler
```

### Dispenser Class (`ReplicatedStorage/ModuleScript.lua`)

```lua
-- Dispenser.ModuleScript (Shared)
-- Generic dispenser class - clones items from Templates folder

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Dispenser = {}
Dispenser.__index = Dispenser

function Dispenser.new(itemType, capacity)
    local self = setmetatable({}, Dispenser)
    self.itemType = itemType
    self.capacity = capacity
    self.remaining = capacity
    return self
end

function Dispenser:dispense()
    if self.remaining <= 0 then
        return nil
    end

    local templates = ReplicatedStorage:FindFirstChild("Templates")
    if not templates then
        warn("Dispenser: Templates folder not found")
        return nil
    end

    local template = templates:FindFirstChild(self.itemType)
    if not template then
        warn("Dispenser: Template not found:", self.itemType)
        return nil
    end

    self.remaining = self.remaining - 1
    return template:Clone()
end

function Dispenser:isEmpty()
    return self.remaining <= 0
end

function Dispenser:refill()
    self.remaining = self.capacity
end

return Dispenser
```

### Server Script (`ServerScriptService/Script.server.lua`)

```lua
-- Dispenser.Script (Server)
-- Handles ProximityPrompt interaction and item dispensing

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Dispenser = require(ReplicatedStorage:WaitForChild("Dispenser.ModuleScript"))

local function setupDispenser(model)
    -- Get config from model attributes
    local itemType = model:GetAttribute("DispenseItem") or "Marshmallow"
    local capacity = model:GetAttribute("Capacity") or 10

    -- Create dispenser instance
    local dispenser = Dispenser.new(itemType, capacity)

    -- Find Anchor
    local anchor = model:FindFirstChild("Anchor")
    if not anchor then
        warn("Dispenser: No Anchor found in", model.Name)
        return
    end

    -- Configure mesh from MeshName attribute
    local meshName = model:GetAttribute("MeshName")
    if meshName then
        local mesh = anchor:FindFirstChild(meshName)
        if mesh then
            mesh.Size = anchor.Size
            mesh.CFrame = anchor.CFrame
            mesh.Anchored = true
            anchor.Transparency = 1
        else
            warn("Dispenser: Mesh not found:", meshName)
        end
    end

    -- Find ProximityPrompt
    local prompt = anchor:FindFirstChild("ProximityPrompt")
    if not prompt then
        warn("Dispenser: No ProximityPrompt found in", model.Name)
        return
    end

    -- Set initial remaining count
    model:SetAttribute("Remaining", dispenser.remaining)

    -- Handle interaction
    prompt.Triggered:Connect(function(player)
        local item = dispenser:dispense()
        if item then
            item.Parent = ReplicatedStorage
            model:SetAttribute("Remaining", dispenser.remaining)
            print("Dispenser: Gave", item.Name, "to", player.Name)
        else
            print("Dispenser: Empty")
        end
    end)

    print("Dispenser: Set up", model.Name, "(DispenseItem:" .. itemType .. ", Capacity:" .. capacity .. ")")
end

-- Wait for model in RuntimeAssets
local runtimeAssets = game.Workspace:WaitForChild("RuntimeAssets")
local model = runtimeAssets:WaitForChild("Dispenser")
setupDispenser(model)

print("Dispenser.Script loaded")
```

### Dispenser Model Attributes (set in Studio)
- `DispenseItem` (string): Item type to dispense, e.g., "Marshmallow"
- `Capacity` (number): Maximum items, e.g., 10
- `MeshName` (string): Optional mesh child name under Anchor
- `Remaining` (number): Current count (set by script, auto-replicates)

### Studio Setup Required
- **Anchor**: Part inside Dispenser model
- **ProximityPrompt**: Child of Anchor
- **Mesh** (optional): MeshPart child of Anchor, named in MeshName attribute

---

## 4. Architecture Cleanup

### Problem Discovered
Module-specific logic had been mixed into Player and System scripts, breaking the modular architecture.

### Design Rule Established
> **"Module specific logic should NEVER be in a System or Player script."**

### Solution
Nuked all scripts and rebuilt from scratch with proper separation of concerns.

---

## 5. System Bootstrap Restructure

### Concept
System is **self-bootstrapping** - it extracts its own service folders, then deploys assets. This allows System to be exported and dropped into any project.

### System Structure

```
src/System/
├── init.meta.json              # className: "Folder"
├── Script.server.lua           # Main bootstrap script
├── Player/                     # Child module (bootstrapped by System)
│   ├── init.meta.json          # className: "Folder"
│   └── [service folders]
├── ReplicatedStorage/          # System's own service content
├── ServerScriptService/        # System's own service content
└── StarterPlayerScripts/       # System's own service content
```

### Bootstrap Flow
1. System extracts its own service folders (ReplicatedStorage, ServerScriptService, StarterPlayerScripts)
2. System bootstraps child modules (like Player) the same way
3. System deploys Assets from `ReplicatedStorage/Assets` to `Workspace/RuntimeAssets`
4. During asset deployment, service folders are extracted from each asset Model

### System Script (`Script.server.lua`)

```lua
-- System.Script (Server)
-- Self-bootstrapping script - extracts own service folders, then deploys assets

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPlayer = game:GetService("StarterPlayer")
local Workspace = game:GetService("Workspace")

local System = script.Parent

local SERVICE_FOLDERS = {
    ReplicatedStorage = ReplicatedStorage,
    ServerScriptService = ServerScriptService,
    StarterPlayerScripts = StarterPlayer.StarterPlayerScripts,
}

local function deployServiceFolder(sourceFolder, targetService, namePrefix)
    for _, child in ipairs(sourceFolder:GetChildren()) do
        local clone = child:Clone()
        if namePrefix then
            clone.Name = namePrefix .. "." .. child.Name
        end
        clone.Parent = targetService
        print("System: Deployed", clone.Name, "to", targetService.Name)
    end
end

local function bootstrapModule(module, moduleName)
    for folderName, service in pairs(SERVICE_FOLDERS) do
        local serviceFolder = module:FindFirstChild(folderName)
        if serviceFolder then
            deployServiceFolder(serviceFolder, service, moduleName)
            serviceFolder:Destroy()
        end
    end
end

local function bootstrapSelf()
    bootstrapModule(System, "System")

    for _, child in ipairs(System:GetChildren()) do
        if child:IsA("Folder") and not SERVICE_FOLDERS[child.Name] then
            bootstrapModule(child, child.Name)
            print("System: Bootstrapped module", child.Name)
        end
    end

    print("System: Self-bootstrap complete")
end

local function bootstrapAssets()
    local runtimeAssets = Instance.new("Folder")
    runtimeAssets.Name = "RuntimeAssets"
    runtimeAssets.Parent = Workspace

    local assetsFolder = ReplicatedStorage:FindFirstChild("Assets")
    if not assetsFolder then
        warn("System: Assets folder not found in ReplicatedStorage")
        return
    end

    for _, asset in ipairs(assetsFolder:GetChildren()) do
        if asset:IsA("Model") then
            local clone = asset:Clone()
            local assetName = clone.Name

            for folderName, service in pairs(SERVICE_FOLDERS) do
                local serviceFolder = clone:FindFirstChild(folderName)
                if serviceFolder then
                    deployServiceFolder(serviceFolder, service, assetName)
                    serviceFolder:Destroy()
                end
            end

            clone.Parent = runtimeAssets
            print("System: Deployed", assetName, "to RuntimeAssets")
        end
    end
end

bootstrapSelf()
bootstrapAssets()

print("System.Script loaded")
```

### Script Naming Convention
Extracted scripts get prefixed with their source module name:
- `Dispenser.ModuleScript` (from Dispenser asset)
- `Dispenser.Script` (from Dispenser asset)
- `System.SomeModule` (from System)
- `Player.SomeScript` (from Player module)

---

## 6. Design Rules Established

### Rule 1: Template Components in Studio
> **"Template components are always created in Studio, not through code."**

This includes:
- Folders (like Templates, RuntimeAssets structure)
- Events (BindableEvent, RemoteEvent)
- UI elements (BillboardGui, etc.)
- ProximityPrompts

**Rationale**: Reduces code surface, increases readability, makes structure visible in Studio.

### Rule 2: Attributes for Replicated State
Instead of using BindableEvents or RemoteEvents for simple state like "remaining count":
- Use `model:SetAttribute("Remaining", value)` on server
- Attributes automatically replicate to clients
- Clients can use `model:GetAttributeChangedSignal("Remaining")` to react

### Rule 3: Module Isolation
Module-specific logic stays within module boundaries. System and Player handle generic functionality only.

---

## 7. Rojo Project Configuration

### `default.project.json`

```json
{
  "name": "v1",
  "tree": {
    "$className": "DataModel",

    "ReplicatedStorage": {
      "Authentication": {
        "$path": "src/Authentication/Shared/Authentication.shared.lua"
      },
      "Permissions": {
        "$path": "src/Authentication/Shared/Permissions.shared.lua"
      },
      "Assets": {
        "$path": "src/Assets"
      }
    },

    "ServerScriptService": {
      "System": {
        "$path": "src/System"
      },
      "Authentication": {
        "$path": "src/Authentication/Server"
      }
    },

    "StarterPlayer": {
      "StarterPlayerScripts": {
        "Authentication": {
          "$path": "src/Authentication/Client"
        }
      }
    }
  }
}
```

---

## 8. Errors Encountered & Fixed

| Error | Cause | Fix |
|-------|-------|-----|
| `className "Dispenser" invalid` | Used asset name instead of Roblox class | Changed to `"Model"` |
| Rojo sync warnings (InstanceMap) | Stale sync state | Disconnect/reconnect Rojo |
| Infinite yield on `Dispenser.ModuleScript` | Scripts not extracted before `WaitForChild` | Fixed bootstrap order |
| Model in wrong location | Dispenser accidentally in Workspace | Moved to `ReplicatedStorage.Assets` |
| HUD not updating | BillboardGui lookup failing | Removed HUD, used Attributes |
| Nested git repo | Framework/v1 had own .git | Removed nested .git |
| Git identity not set | No global git config | Set user.name and user.email |

---

## 9. Git Commit

Successfully committed all changes with proper structure.

---

## 10. Wally Package Management Setup

### Installation
- Downloaded Wally v0.3.2 for Linux
- Installed to `~/.local/bin/wally`
- Added to PATH in `.bashrc`

### Package Configuration

Created `wally.toml`:

```toml
[package]
name = "libpurefiction/system"
version = "0.1.0"
registry = "https://github.com/UpliftGames/wally-index"
realm = "server"
description = "Self-bootstrapping framework for Roblox games"
license = "MIT"
authors = ["LibPureFiction"]

[dependencies]
```

### Updated `.gitignore`

Added:
```
# Wally
Packages/
wally.lock
```

### Publishing (Future)
1. `wally login` (requires GitHub auth)
2. `wally publish`

### Consuming (In other projects)
```toml
# In consumer's wally.toml
[dependencies]
System = "libpurefiction/system@0.1.0"
```

---

## 11. Current File Structure

```
Framework/v1/
├── default.project.json
├── wally.toml
├── .gitignore
├── Logs/
│   └── 2025-12-25_19-08-36_session-log.md
└── src/
    ├── Assets/
    │   └── Dispenser/
    │       ├── init.meta.json
    │       ├── ReplicatedStorage/
    │       │   └── ModuleScript.lua
    │       └── ServerScriptService/
    │           └── Script.server.lua
    ├── Authentication/
    │   ├── Client/
    │   ├── Server/
    │   └── Shared/
    │       ├── Authentication.shared.lua
    │       └── Permissions.shared.lua
    └── System/
        ├── init.meta.json
        ├── Script.server.lua
        └── Player/
            └── init.meta.json
```

---

## 12. Studio Setup Required

The following must be created manually in Roblox Studio (per design rules):

### ReplicatedStorage
- `Templates/` folder containing item templates (e.g., Marshmallow part)

### Dispenser Model (in ReplicatedStorage/Assets after Rojo sync)
- `Anchor` (Part) with:
  - `ProximityPrompt` child
  - Optional mesh child (MeshPart)
- Attributes:
  - `DispenseItem`: string (e.g., "Marshmallow")
  - `Capacity`: number (e.g., 10)
  - `MeshName`: string (optional, mesh child name)

---

## 13. Key Concepts Reference

### Rojo
- File-based Roblox development tool
- Syncs filesystem to Studio in real-time
- Use `.meta.json` files to control instance properties

### init.meta.json
Defines className for Rojo folders:
```json
{"className": "Model"}   // Creates Model instead of Folder
{"className": "Folder"}  // Explicitly Folder (default)
{"className": "Tool"}    // Creates Tool
```

### Service Folder Extraction Pattern
Models/Folders can contain service subfolders that get extracted during bootstrap:
- `ServerScriptService/` - Server scripts
- `ReplicatedStorage/` - Shared modules
- `StarterPlayerScripts/` - Client scripts

This enables self-contained, portable modules.

### Wally
- Roblox package manager (like npm)
- Packages published to wally-index on GitHub
- Install with `wally install`
- Dependencies go to `Packages/` folder

---

## 14. Next Steps (Not Started)

1. Publish System package to Wally registry
2. Create additional asset modules following Dispenser pattern
3. Build out Player module functionality
4. Set up CI/CD for package publishing
