# Session Log: 2025-12-26 (Session 6)

## Overview

This session added the GlobalTimer asset for round-based gameplay and updated Orchestrator to handle multiple game events asynchronously. The game loop now supports "toast as many marshmallows as possible before time runs out" with strategic tension between speed and accuracy.

---

## 1. GlobalTimer Asset

### Concept

GlobalTimer is a global round timer that:
1. Counts down from a configurable duration (M.SS format)
2. Broadcasts time updates to all clients via RemoteEvent
3. Fires a BindableEvent when expired for Orchestrator to observe
4. Exposes Start/Stop BindableFunctions for external control

### Filesystem Structure

```
src/Assets/GlobalTimer/
├── init.meta.json              # className: "Model"
├── ReplicatedStorage/
│   ├── TimerUpdate.rbxm        # RemoteEvent (server → clients)
│   └── TimerExpired.rbxm       # BindableEvent (server → server)
├── ServerScriptService/
│   └── Script.server.lua       # Timer logic
└── StarterGui/
    ├── LocalScript.client.lua  # HUD updates
    └── ScreenGui.rbxm          # Timer display UI
```

### Model Attributes

| Attribute | Type | Description | Example |
|-----------|------|-------------|---------|
| `CountdownStart` | number | Duration in M.SS format | `3.00` = 3 minutes |
| `TimeRemaining` | number | Current seconds (set by script) | `180` |

### Server Script (Script.server.lua)

```lua
-- GlobalTimer.Script (Server)
-- Global round timer - counts down and fires events for HUD and Orchestrator

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Parse CountdownStart attribute (M.SS format where SS must be 00-59)
local function parseCountdown(value)
    if type(value) ~= "number" or value < 0 then
        return nil
    end

    local minutes = math.floor(value)
    local decimalPart = value - minutes
    local seconds = math.floor(decimalPart * 100 + 0.5)

    if seconds > 59 then
        warn("GlobalTimer: Invalid CountdownStart - seconds must be <= 59")
        return nil
    end

    return (minutes * 60) + seconds
end

local function setupGlobalTimer(model)
    local countdownStart = model:GetAttribute("CountdownStart") or 3.00
    local totalSeconds = parseCountdown(countdownStart) or 180

    local timerUpdate = ReplicatedStorage:WaitForChild("GlobalTimer.TimerUpdate")
    local timerExpired = ReplicatedStorage:WaitForChild("GlobalTimer.TimerExpired")

    local timerThread = nil
    local timerGeneration = 0
    local isRunning = false
    local timeRemaining = 0

    local function formatTime(seconds)
        local mins = math.floor(seconds / 60)
        local secs = seconds % 60
        return string.format("%d:%02d", mins, secs)
    end

    local function broadcastUpdate()
        timerUpdate:FireAllClients({
            timeRemaining = timeRemaining,
            formatted = formatTime(timeRemaining),
            isRunning = isRunning,
        })
    end

    local function start()
        if timerThread then
            pcall(function() task.cancel(timerThread) end)
        end

        timerGeneration = timerGeneration + 1
        local myGeneration = timerGeneration

        isRunning = true
        timeRemaining = totalSeconds
        model:SetAttribute("TimeRemaining", timeRemaining)
        broadcastUpdate()

        timerThread = task.spawn(function()
            while timeRemaining > 0 and isRunning and myGeneration == timerGeneration do
                task.wait(1)
                timeRemaining = timeRemaining - 1
                model:SetAttribute("TimeRemaining", timeRemaining)
                broadcastUpdate()
            end

            if isRunning and myGeneration == timerGeneration then
                isRunning = false
                broadcastUpdate()
                timerExpired:Fire()
            end
        end)
    end

    local function stop()
        if timerThread then
            pcall(function() task.cancel(timerThread) end)
        end
        isRunning = false
        broadcastUpdate()
    end

    -- Expose Start/Stop via BindableFunctions
    local startFunction = Instance.new("BindableFunction")
    startFunction.Name = "Start"
    startFunction.OnInvoke = function() start() return true end
    startFunction.Parent = model

    local stopFunction = Instance.new("BindableFunction")
    stopFunction.Name = "Stop"
    stopFunction.OnInvoke = function() stop() return true end
    stopFunction.Parent = model
end
```

### LocalScript (LocalScript.client.lua)

```lua
-- GlobalTimer.LocalScript (Client)
-- Listens to TimerUpdate events and updates the HUD

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local function setupHUD()
    local timerUpdate = ReplicatedStorage:WaitForChild("GlobalTimer.TimerUpdate")
    local screenGui = playerGui:WaitForChild("GlobalTimer.ScreenGui")
    local timerLabel = screenGui:FindFirstChild("TimerLabel", true)

    local function updateDisplay(data)
        if timerLabel then
            if data.isRunning then
                timerLabel.Text = data.formatted
            else
                timerLabel.Text = data.timeRemaining <= 0 and "TIME!" or data.formatted
            end
        end
    end

    timerUpdate.OnClientEvent:Connect(updateDisplay)

    if timerLabel then
        timerLabel.Text = "--:--"
    end
end

setupHUD()
```

### ScreenGui Structure (Created in Studio)

```
ScreenGui
└── Frame
    └── TimerLabel (TextLabel)
```

---

## 2. Dispenser Updates

### Reset BindableFunction

Added Reset function for Orchestrator to refill the dispenser:

```lua
local resetFunction = Instance.new("BindableFunction")
resetFunction.Name = "Reset"
resetFunction.OnInvoke = function()
    dispenser:refill()
    model:SetAttribute("Remaining", dispenser.remaining)
    return true
end
resetFunction.Parent = model
```

### Empty Event

Added `Dispenser.Empty` BindableEvent that fires when the last item is dispensed:

```lua
-- Create Empty event for Orchestrator
local emptyEvent = Instance.new("BindableEvent")
emptyEvent.Name = "Dispenser.Empty"
emptyEvent.Parent = ReplicatedStorage

-- In prompt.Triggered handler:
if dispenser:isEmpty() then
    emptyEvent:Fire()
end
```

---

## 3. Orchestrator Rewrite

### Event-Driven Architecture

Orchestrator now listens to multiple events and responds appropriately:

| Event | Source | Response |
|-------|--------|----------|
| `Scoreboard.RoundComplete` | Per-submission | Reset TimedEvaluator only |
| `GlobalTimer.TimerExpired` | Time ran out | Full reset (all assets) |
| `Dispenser.Empty` | No marshmallows left | Full reset (all assets) |

### Server Script (Script.server.lua)

```lua
-- Orchestrator.Script (Server)
-- Coordinates game flow - listens to events and triggers appropriate resets

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function setupOrchestrator()
    local runtimeAssets = game.Workspace:WaitForChild("RuntimeAssets")

    -- Get asset controls
    local globalTimer = runtimeAssets:WaitForChild("GlobalTimer")
    local globalTimerStart = globalTimer:WaitForChild("Start")

    local dispenser = runtimeAssets:WaitForChild("Dispenser")
    local dispenserReset = dispenser:WaitForChild("Reset")

    local timedEvaluator = runtimeAssets:WaitForChild("TimedEvaluator")
    local timedEvaluatorReset = timedEvaluator:WaitForChild("Reset")

    -- Per-submission reset
    local roundComplete = ReplicatedStorage:WaitForChild("Scoreboard.RoundComplete")
    roundComplete.Event:Connect(function(result)
        task.wait(1)
        timedEvaluatorReset:Invoke()
    end)

    -- Full reset function
    local function fullReset(reason)
        print("Orchestrator:", reason, "- resetting all assets")
        task.wait(3)
        dispenserReset:Invoke()
        timedEvaluatorReset:Invoke()
        globalTimerStart:Invoke()
    end

    -- Listen for full reset triggers
    local timerExpired = ReplicatedStorage:WaitForChild("GlobalTimer.TimerExpired")
    timerExpired.Event:Connect(function()
        fullReset("GlobalTimer expired")
    end)

    local dispenserEmpty = ReplicatedStorage:WaitForChild("Dispenser.Empty")
    dispenserEmpty.Event:Connect(function()
        fullReset("Dispenser empty")
    end)

    -- Start GlobalTimer on game load
    globalTimerStart:Invoke()
end

setupOrchestrator()
```

---

## 4. Game Loop (Complete)

### Flow

1. **Game Start** → Orchestrator starts GlobalTimer
2. **Player grabs marshmallow** → Dispenser gives item, tracks remaining
3. **Player cooks** → ZoneController ticks `cook` method, ToastLevel increases
4. **Player submits** → TimedEvaluator scores accuracy, Scoreboard updates HUD
5. **Scoreboard fires RoundComplete** → Orchestrator resets TimedEvaluator only
6. **Repeat steps 2-5** until...

### Round End Triggers

| Trigger | Event | Result |
|---------|-------|--------|
| Time runs out | `GlobalTimer.TimerExpired` | Full reset, new round |
| Dispenser empty | `Dispenser.Empty` | Full reset, new round |

### Strategic Tension

- **Rush** = finish fast, but poor accuracy scores
- **Take time** = better accuracy, but might run out of time
- **Spam dispenser** = round ends early when marshmallows run out

---

## 5. Architecture Patterns Reinforced

### Event-Driven Communication

Assets fire BindableEvents, Orchestrator listens and responds. No asset directly calls another asset's functions.

```
TimedEvaluator → EvaluationComplete → Scoreboard → RoundComplete → Orchestrator
GlobalTimer → TimerExpired → Orchestrator
Dispenser → Empty → Orchestrator
```

### Orchestrator as Central Coordinator

Orchestrator is the "swiss army knife" - it handles all game flow logic:
- Listens to multiple events asynchronously
- Triggers appropriate resets based on event type
- Starts the game on load

### Assets Expose BindableFunctions

Assets expose Start/Stop/Reset functions. External control is possible, but assets don't know who's calling.

---

## 6. Files Changed

### New Files

```
src/Assets/GlobalTimer/
├── init.meta.json
├── ReplicatedStorage/
│   ├── TimerUpdate.rbxm
│   └── TimerExpired.rbxm
├── ServerScriptService/
│   └── Script.server.lua
└── StarterGui/
    ├── LocalScript.client.lua
    └── ScreenGui.rbxm
```

### Modified Files

- `src/Assets/Dispenser/ServerScriptService/Script.server.lua` - Added Reset + Empty event
- `src/Assets/Orchestrator/ServerScriptService/Script.server.lua` - Multi-event listener

---

## 7. Current File Structure

```
Framework/v1/
└── src/
    ├── Assets/
    │   ├── Dispenser/           # Reset + Empty event
    │   ├── ZoneController/
    │   ├── TimedEvaluator/
    │   ├── Scoreboard/
    │   ├── Orchestrator/        # Multi-event coordinator
    │   └── GlobalTimer/         # NEW - Round timer
    ├── Templates/
    │   └── Marshmallow/
    └── System/
```

---

## 8. Next Steps

1. Display target ToastLevel on HUD (so players know what to aim for)
2. Display TimedEvaluator countdown on HUD
3. Visual feedback for marshmallow cooking (color change)
4. End-of-round summary screen
5. Leaderboard for multiplayer
