# Session Log: 2025-12-26 (Session 4)

## Overview

This session focused on building the TimedEvaluator asset (timed submission/scoring system) and the Scoreboard asset (score calculation and HUD display). Also updated System to support StarterGui extraction and refined the scoring algorithm.

---

## 1. TimedEvaluator Asset

### Concept

TimedEvaluator (formerly "Camper") is a timed evaluation system that:
1. Accepts items of a specific type (configured via `AcceptType` attribute)
2. Compares a specified attribute on the item against a target value
3. Runs a countdown timer in a background thread
4. Evaluates when player submits OR time runs out
5. Fires a BindableEvent with results for other systems to observe

### Design Decisions

**Attribute-Based Configuration**
- `AcceptType`: What item type to accept (e.g., "Marshmallow")
- `EvalTarget`: Which attribute to read from item (e.g., "ToastLevel")
- `TargetValue`: Target value to compare against (randomized on reset)
- `Countdown`: Starting countdown in seconds
- `TimeRemaining`: Current countdown (set by script, replicates for UI)

**Reset Pattern**
- `reset()` called once on load, then by external orchestrator
- Sets random TargetValue (1-10 for now)
- Resets timer
- Exposes `Reset` BindableFunction for orchestrator to invoke

**Component Placement**
- EvaluationComplete BindableEvent placed under Anchor (per design rule: components created in Studio)
- User creates physical components, exports as .rbxm

### Filesystem Structure

```
src/Assets/TimedEvaluator/
├── init.meta.json              # className: "Model"
├── Anchor.rbxm                 # Part + ProximityPrompt + EvaluationComplete
└── ServerScriptService/
    └── Script.server.lua       # Timer + evaluation logic
```

### Server Script (Script.server.lua)

```lua
-- TimedEvaluator.Script (Server)
-- Timed evaluation system - accepts items and compares against target value

local Players = game:GetService("Players")

local function setupTimedEvaluator(model)
    -- Config from attributes
    local acceptType = model:GetAttribute("AcceptType") or "Marshmallow"
    local evalTarget = model:GetAttribute("EvalTarget") or "ToastLevel"
    local countdown = model:GetAttribute("Countdown") or 30

    -- Find components
    local anchor = model:FindFirstChild("Anchor")
    local prompt = anchor:FindFirstChild("ProximityPrompt")
    local evaluationComplete = anchor:FindFirstChild("EvaluationComplete")

    -- Internal state
    local timerThread = nil
    local isRunning = false
    local hasEvaluated = false

    -- Evaluate submitted item (or nil if timeout)
    local function evaluate(item, player)
        if hasEvaluated then return end
        hasEvaluated = true
        isRunning = false

        -- Stop timer if running
        if timerThread then
            task.cancel(timerThread)
            timerThread = nil
        end

        local targetValue = model:GetAttribute("TargetValue") or 0
        local submittedValue = nil
        local score = nil

        if item then
            submittedValue = item:GetAttribute(evalTarget) or 0
            score = math.abs(targetValue - submittedValue)
        end

        -- Fire event with result
        local timeRemaining = model:GetAttribute("TimeRemaining") or 0
        evaluationComplete:Fire({
            submitted = item ~= nil,
            submittedValue = submittedValue,
            targetValue = targetValue,
            score = score,
            player = player,
            timeRemaining = timeRemaining,
            countdown = countdown,
        })
    end

    -- Start countdown timer
    local function startTimer()
        timerThread = task.spawn(function()
            local timeRemaining = countdown
            model:SetAttribute("TimeRemaining", timeRemaining)

            while timeRemaining > 0 and isRunning do
                task.wait(1)
                timeRemaining = timeRemaining - 1
                model:SetAttribute("TimeRemaining", timeRemaining)
            end

            if isRunning and not hasEvaluated then
                evaluate(nil, nil)
            end
        end)
    end

    -- Reset/init function
    local function reset()
        if timerThread then
            task.cancel(timerThread)
            timerThread = nil
        end

        hasEvaluated = false
        isRunning = true

        local newTarget = math.random(1, 10)
        model:SetAttribute("TargetValue", newTarget)
        model:SetAttribute("TimeRemaining", countdown)

        startTimer()
    end

    -- Find accepted item in player's inventory
    local function findAcceptedItem(player)
        local character = player.Character
        if character then
            for _, child in ipairs(character:GetChildren()) do
                if child:IsA("Tool") and child.Name == acceptType then
                    return child
                end
            end
        end

        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            for _, child in ipairs(backpack:GetChildren()) do
                if child:IsA("Tool") and child.Name == acceptType then
                    return child
                end
            end
        end

        return nil
    end

    -- Handle player interaction
    prompt.Triggered:Connect(function(player)
        if not isRunning or hasEvaluated then return end

        local item = findAcceptedItem(player)
        if not item then return end

        local itemToEvaluate = item
        item:Destroy()

        evaluate(itemToEvaluate, player)
    end)

    -- Expose reset via BindableFunction (for orchestrator)
    local resetFunction = Instance.new("BindableFunction")
    resetFunction.Name = "Reset"
    resetFunction.OnInvoke = function()
        reset()
        return true
    end
    resetFunction.Parent = model

    -- Initial reset on load
    reset()
end

local runtimeAssets = game.Workspace:WaitForChild("RuntimeAssets")
local model = runtimeAssets:WaitForChild("TimedEvaluator")
setupTimedEvaluator(model)
```

### Model Attributes

| Attribute | Type | Description | Example |
|-----------|------|-------------|---------|
| `AcceptType` | string | Item type to accept | `"Marshmallow"` |
| `EvalTarget` | string | Attribute to read from item | `"ToastLevel"` |
| `TargetValue` | number | Target value (set by reset) | `7` |
| `Countdown` | number | Starting countdown seconds | `30` |
| `TimeRemaining` | number | Current countdown (set by script) | `15` |

### Anchor.rbxm Contents

- **Anchor** (Part)
  - **ProximityPrompt** - triggers submission
  - **EvaluationComplete** (BindableEvent) - fires with results

---

## 2. Marshmallow Attribute Rename

Updated Marshmallow template to use `ToastLevel` instead of `CookLevel` to match TimedEvaluator's `EvalTarget` configuration.

**Changes:**
- `cookLevel` variable → `toastLevel`
- `maxCookLevel` → `maxToastLevel`
- `SetAttribute("CookLevel", ...)` → `SetAttribute("ToastLevel", ...)`

The `cook` BindableFunction name was preserved (ZoneController looks for it).

---

## 3. Scoreboard Asset

### Concept

Scoreboard separates scoring logic from presentation:
1. **Server**: Catches BindableEvents from assets (TimedEvaluator), calculates score, fires RemoteEvent
2. **Client**: Listens to RemoteEvent, updates ScreenGui

### Architecture Decision

Initially placed under `src/System/Scoreboard` but moved to `src/Assets/Scoreboard` for architectural consistency - all modules follow the same Asset pattern.

### Filesystem Structure

```
src/Assets/Scoreboard/
├── init.meta.json              # className: "Model"
├── ReplicatedStorage/
│   └── ScoreUpdate.rbxm        # RemoteEvent (created in Studio)
├── ServerScriptService/
│   └── Script.server.lua       # Scoring logic
└── StarterGui/
    ├── LocalScript.client.lua  # HUD updates
    └── ScreenGui.rbxm          # UI (created in Studio)
```

### Scoring Algorithm (60/40 Weighted Balance)

```lua
-- Accuracy component (60% weight, max 60 points)
local accuracyScore = math.max(0, 60 - (diff * 6))

-- Speed component (40% weight, max 40 points)
local speedScore = math.floor((timeRemaining / countdown) * 40)

local score = accuracyScore + speedScore
```

**Example Scores:**

| Diff | Time Left | Accuracy | Speed | Total |
|------|-----------|----------|-------|-------|
| 0 | 30/30 | 60 | 40 | 100 |
| 0 | 15/30 | 60 | 20 | 80 |
| 2 | 30/30 | 48 | 40 | 88 |
| 5 | 10/30 | 30 | 13 | 43 |

### Server Script (Script.server.lua)

```lua
-- Scoreboard.Script (Server)
-- Listens to evaluation events, calculates scores, fires to clients

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function setupScoreboard()
    local scoreUpdate = ReplicatedStorage:WaitForChild("Scoreboard.ScoreUpdate")
    local playerScores = {}

    local function calculateScore(result)
        if not result.submitted then
            return 0
        end

        local diff = result.score or math.abs(result.targetValue - result.submittedValue)
        local timeRemaining = result.timeRemaining or 0
        local countdown = result.countdown or 30

        local accuracyScore = math.max(0, 60 - (diff * 6))
        local speedScore = math.floor((timeRemaining / countdown) * 40)

        return accuracyScore + speedScore
    end

    local function onEvaluationComplete(result)
        local player = result.player
        if not player then return end

        local score = calculateScore(result)
        playerScores[player] = (playerScores[player] or 0) + score

        scoreUpdate:FireClient(player, {
            roundScore = score,
            totalScore = playerScores[player],
            submitted = result.submitted,
            submittedValue = result.submittedValue,
            targetValue = result.targetValue,
        })
    end

    local function connectToTimedEvaluator()
        local runtimeAssets = game.Workspace:WaitForChild("RuntimeAssets")
        local timedEvaluator = runtimeAssets:WaitForChild("TimedEvaluator")
        local anchor = timedEvaluator:WaitForChild("Anchor")
        local evaluationComplete = anchor:WaitForChild("EvaluationComplete")

        evaluationComplete.Event:Connect(onEvaluationComplete)
    end

    game.Players.PlayerRemoving:Connect(function(player)
        playerScores[player] = nil
    end)

    connectToTimedEvaluator()
end

setupScoreboard()
```

### LocalScript (LocalScript.client.lua)

```lua
-- Scoreboard.LocalScript (Client)
-- Listens to ScoreUpdate events and updates the HUD

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local function setupHUD()
    local scoreUpdate = ReplicatedStorage:WaitForChild("Scoreboard.ScoreUpdate")
    local screenGui = playerGui:WaitForChild("Scoreboard.ScreenGui")

    local scoreLabel = screenGui:FindFirstChild("ScoreLabel", true)
    local targetLabel = screenGui:FindFirstChild("TargetLabel", true)

    local function updateDisplay(data)
        if scoreLabel then
            scoreLabel.Text = "Score: " .. tostring(data.totalScore)
        end

        if targetLabel then
            if data.submitted then
                targetLabel.Text = "Target: " .. tostring(data.targetValue) .. " | You: " .. tostring(math.floor(data.submittedValue or 0))
            else
                targetLabel.Text = "Time's up! Target was: " .. tostring(data.targetValue)
            end
        end
    end

    scoreUpdate.OnClientEvent:Connect(updateDisplay)

    if scoreLabel then
        scoreLabel.Text = "Score: 0"
    end
    if targetLabel then
        targetLabel.Text = "Waiting..."
    end
end

setupHUD()
```

### ScreenGui Structure (Created in Studio)

```
ScreenGui
└── Frame
    ├── ScoreLabel (TextLabel)
    └── TargetLabel (TextLabel)
```

---

## 4. System Update: StarterGui Support

Added `StarterGui` to System's `SERVICE_FOLDERS` for extraction:

```lua
local StarterGui = game:GetService("StarterGui")

local SERVICE_FOLDERS = {
    ReplicatedStorage = ReplicatedStorage,
    ServerScriptService = ServerScriptService,
    StarterPlayerScripts = StarterPlayer.StarterPlayerScripts,
    StarterGui = StarterGui,  -- NEW
}
```

This enables assets to include StarterGui content that gets extracted during bootstrap.

---

## 5. Current File Structure

```
Framework/v1/
├── default.project.json
├── wally.toml
├── .gitignore
├── Logs/
│   ├── 2025-12-25_19-08-36_session-log.md
│   ├── 2025-12-25_20-08-18_session-log.md
│   ├── 2025-12-25_21-05-39_session-log.md
│   └── 2025-12-26_08-53-58_session-log.md
└── src/
    ├── Assets/
    │   ├── Dispenser/
    │   │   ├── init.meta.json
    │   │   ├── Anchor.rbxm
    │   │   ├── ReplicatedStorage/
    │   │   │   └── ModuleScript.lua
    │   │   └── ServerScriptService/
    │   │       └── Script.server.lua
    │   ├── ZoneController/
    │   │   ├── init.meta.json
    │   │   ├── Zone.rbxm
    │   │   └── ServerScriptService/
    │   │       └── Script.server.lua
    │   ├── TimedEvaluator/
    │   │   ├── init.meta.json
    │   │   ├── Anchor.rbxm
    │   │   └── ServerScriptService/
    │   │       └── Script.server.lua
    │   └── Scoreboard/
    │       ├── init.meta.json
    │       ├── ReplicatedStorage/
    │       │   └── ScoreUpdate.rbxm
    │       ├── ServerScriptService/
    │       │   └── Script.server.lua
    │       └── StarterGui/
    │           ├── LocalScript.client.lua
    │           └── ScreenGui.rbxm
    ├── Templates/
    │   └── Marshmallow/
    │       ├── init.meta.json
    │       ├── Handle.rbxm
    │       ├── cook/
    │       │   └── init.meta.json
    │       └── Script.server.lua
    ├── Authentication/
    │   └── ...
    └── System/
        ├── init.meta.json
        ├── Script.server.lua
        └── Player/
            └── init.meta.json
```

---

## 6. Test Flow (Working)

1. Player approaches Dispenser → triggers ProximityPrompt → gets Marshmallow in Backpack
2. Player walks into ZoneController zone → Marshmallow's `cook` method called each tick
3. Marshmallow's `ToastLevel` attribute increases based on heat and time
4. TimedEvaluator countdown runs in background, `TimeRemaining` attribute updates
5. Player approaches TimedEvaluator → triggers ProximityPrompt → Marshmallow submitted
6. TimedEvaluator fires `EvaluationComplete` with result data
7. Scoreboard catches event → calculates score (60% accuracy + 40% speed)
8. Scoreboard fires `ScoreUpdate` RemoteEvent to player
9. HUD LocalScript catches event → updates ScoreLabel and TargetLabel

---

## 7. Design Patterns Reinforced

### Assets are Self-Contained
Each asset contains all its service folders (ReplicatedStorage, ServerScriptService, StarterGui, etc.). System extracts them during bootstrap.

### Components Created in Studio
Physical components, UI elements, and events (BindableEvent, RemoteEvent) created in Studio and exported as .rbxm files.

### Logic/Presentation Separation
Scoreboard demonstrates separating logic (server calculates score) from presentation (client updates UI). Communication via RemoteEvent.

### Attribute-Based Configuration
Assets configured via Attributes set in Studio. Scripts read attributes at runtime. State attributes (like TimeRemaining) auto-replicate to clients.

---

## 8. Next Steps (Not Started)

1. Style the Scoreboard ScreenGui (positioning, colors, fonts)
2. Build game loop orchestrator (reset TimedEvaluator between rounds)
3. Create RoastStick tool (holds Marshmallow)
4. Add visual feedback for cooking (color change, particles)
5. Build Campfire visual asset
6. Display TimedEvaluator's TargetValue and TimeRemaining on HUD
