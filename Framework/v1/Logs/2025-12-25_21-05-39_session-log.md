# Session Log: 2025-12-25 (Session 3)

## Overview

This session focused on building the ZoneController asset module - an event-driven zone detection system that scans entities for matching callback methods and invokes them while entities remain in the zone. Also integrated with Dispenser and created the Marshmallow template for testing.

---

## 1. Initial Context

- Read previous session logs to restore context
- Discussed Studio's File → Export as .obj feature (exports geometry to Wavefront OBJ format for external 3D tools)
- Noted potential future workflow: rough out terrain in Studio → export .obj → Claude can analyze/modify geometry programmatically

---

## 2. ZoneController Design

### Concept

ZoneController is a generic zone-based interaction system. It:
1. Detects entities entering/leaving a defined zone
2. Deep searches entities for a specific callback method (e.g., `cook`)
3. Maintains an "attendance" table of matching instances
4. Calls the callback method on each tick while entity is in zone
5. Passes internal state (deltaTime, zone info, future: heat) to callbacks

### Design Decisions

**Event-Driven Zone Detection**
- Used `Touched`/`TouchEnded` events instead of polling
- More efficient than Region3 queries or frame-based checks

**Server-Authoritative State**
- Server owns the attendance table
- Server invokes callback methods
- Clients react to replicated attributes for visuals

**Touch Counting for Reliable Exit Detection**
- Initial implementation used `GetTouchingParts()` which is unreliable with `CanCollide=false`
- Fixed by counting touch events per entity
- Increment on `Touched`, decrement on `TouchEnded`
- Entity enters on first touch (count == 1), exits when count reaches 0

**BindableFunction for Callbacks**
- Entities expose methods via BindableFunction children
- ZoneController searches for BindableFunction with name matching `MatchCallback` attribute
- Invokes with state table: `{ deltaTime, tickRate, zoneCenter, zoneSize }`

---

## 3. ZoneController Implementation

### Filesystem Structure

```
src/Assets/ZoneController/
├── init.meta.json              # className: "Model"
├── Zone.rbxm                   # Physical trigger part (exported from Studio)
└── ServerScriptService/
    └── Script.server.lua       # Zone detection + tick loop
```

### Model Attributes

| Attribute | Type | Description | Example |
|-----------|------|-------------|---------|
| `MatchCallback` | string | Name of BindableFunction to search for | `"cook"` |
| `TickRate` | number | Seconds between callback invocations | `0.5` |

### Server Script (Script.server.lua)

```lua
-- ZoneController.Script (Server)
-- Event-driven zone detection with tick-based method invocation

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Deep search for instances with BindableFunction child matching methodName
local function findMethodInTree(root, methodName)
    local results = {}

    local function search(instance)
        local callback = instance:FindFirstChild(methodName)
        if callback and callback:IsA("BindableFunction") then
            table.insert(results, instance)
        end

        for _, child in ipairs(instance:GetChildren()) do
            search(child)
        end
    end

    search(root)
    return results
end

-- Get entity root from hit part
-- For players, returns Player object (to search Backpack too)
local function getEntityRoot(hit)
    local current = hit
    while current and current ~= workspace do
        local player = Players:GetPlayerFromCharacter(current)
        if player then
            return player, "player"
        end
        current = current.Parent
    end

    current = hit.Parent
    while current and current ~= workspace do
        if current:IsA("Model") then
            if current:FindFirstChild("Humanoid") or current.PrimaryPart then
                return current, "model"
            end
        end
        current = current.Parent
    end

    return nil, nil
end

local function setupZoneController(model)
    local matchCallback = model:GetAttribute("MatchCallback")
    local tickRate = model:GetAttribute("TickRate") or 0.5

    local zone = model:FindFirstChild("Zone")
    zone.CanCollide = false
    zone.CanTouch = true

    local attendance = {}
    local touchCounts = {}

    local function onEntityEnter(entityRoot, entityType)
        local matches = findMethodInTree(entityRoot, matchCallback)
        if #matches > 0 then
            attendance[entityRoot] = {
                instances = {},
                entityType = entityType
            }
            for _, instance in ipairs(matches) do
                attendance[entityRoot].instances[instance] = true
            end
            print("ZoneController: Entity entered with", #matches, "matching instances")
        end
    end

    local function onEntityExit(entityRoot)
        if attendance[entityRoot] then
            attendance[entityRoot] = nil
            print("ZoneController: Entity left")
        end
    end

    -- Touch counting for reliable entry/exit
    zone.Touched:Connect(function(hit)
        local entityRoot, entityType = getEntityRoot(hit)
        if entityRoot then
            touchCounts[entityRoot] = (touchCounts[entityRoot] or 0) + 1
            if touchCounts[entityRoot] == 1 then
                onEntityEnter(entityRoot, entityType)
            end
        end
    end)

    zone.TouchEnded:Connect(function(hit)
        local entityRoot, entityType = getEntityRoot(hit)
        if entityRoot and touchCounts[entityRoot] then
            touchCounts[entityRoot] = touchCounts[entityRoot] - 1
            if touchCounts[entityRoot] <= 0 then
                touchCounts[entityRoot] = nil
                onEntityExit(entityRoot)
            end
        end
    end)

    -- Tick loop
    local lastTick = 0
    RunService.Heartbeat:Connect(function(deltaTime)
        lastTick = lastTick + deltaTime
        if lastTick < tickRate then return end

        local dt = lastTick
        lastTick = 0

        local state = {
            deltaTime = dt,
            tickRate = tickRate,
            zoneCenter = zone.Position,
            zoneSize = zone.Size,
        }

        for entityRoot, data in pairs(attendance) do
            for instance, _ in pairs(data.instances) do
                if not instance:IsDescendantOf(game) then
                    data.instances[instance] = nil
                    continue
                end

                local callback = instance:FindFirstChild(matchCallback)
                if callback then
                    pcall(function() callback:Invoke(state) end)
                end
            end
        end
    end)
end

local runtimeAssets = game.Workspace:WaitForChild("RuntimeAssets")
local model = runtimeAssets:WaitForChild("ZoneController")
setupZoneController(model)
```

### Zone Part Requirements

- `CanCollide = false` (entities walk through)
- `CanTouch = true` (events fire)
- `Anchored = true`
- Export as `Zone.rbxm` for Rojo management

---

## 4. Marshmallow Template

### Filesystem Structure

```
src/Templates/Marshmallow/
├── init.meta.json              # className: "Tool"
├── Handle.rbxm                 # Physical part (required for Tools)
├── cook/
│   └── init.meta.json          # className: "BindableFunction"
└── Script.server.lua           # Cooking logic
```

### Cooking Script (Script.server.lua)

```lua
-- Marshmallow.Script (Server)
-- Handles cooking logic when called by ZoneController

local tool = script.Parent
local cookFunction = tool:WaitForChild("cook")

local cookLevel = 0
local maxCookLevel = 150

tool:SetAttribute("CookLevel", cookLevel)

cookFunction.OnInvoke = function(state)
    local heat = state.heat or 10
    local dt = state.deltaTime or 0.5

    cookLevel = math.min(cookLevel + (heat * dt), maxCookLevel)
    tool:SetAttribute("CookLevel", cookLevel)

    if cookLevel < 50 then
        print("Marshmallow: Warming up...", math.floor(cookLevel))
    elseif cookLevel < 100 then
        print("Marshmallow: Cooking nicely!", math.floor(cookLevel))
    elseif cookLevel < 120 then
        print("Marshmallow: Golden brown!", math.floor(cookLevel))
    else
        print("Marshmallow: Starting to burn!", math.floor(cookLevel))
    end

    return cookLevel
end
```

### Key Points

- Tool requires a Part named `Handle` (create in Studio, export as .rbxm)
- `cook` BindableFunction created via `init.meta.json` with className
- `CookLevel` attribute replicates to clients for UI/visuals
- Heat will eventually vary by distance from zone center (not yet implemented)

---

## 5. Dispenser Updates

Updated to put dispensed items in player's Backpack instead of ReplicatedStorage:

```lua
prompt.Triggered:Connect(function(player)
    local item = dispenser:dispense()
    if item then
        item.Parent = player.Backpack  -- Changed from ReplicatedStorage
        model:SetAttribute("Remaining", dispenser.remaining)
    end
end)
```

---

## 6. Project Configuration Updates

Added Templates folder to Rojo project:

```json
"ReplicatedStorage": {
    "Assets": { "$path": "src/Assets" },
    "Templates": { "$path": "src/Templates" }
}
```

---

## 7. Bug Fixed: Zone Exit Detection

### Problem
Marshmallow kept cooking after player left the zone.

### Cause
`GetTouchingParts()` is unreliable with `CanCollide=false` zones.

### Solution
Replaced with touch counting:
- Increment counter on `Touched`
- Decrement counter on `TouchEnded`
- Entity enters when count goes from 0 → 1
- Entity exits when count goes from 1 → 0

This properly handles multi-part characters where each body part triggers separate events.

---

## 8. Deep Search Confirmation

The `findMethodInTree` function already performs recursive deep search. Nested structures like:

```
Player
└── Backpack
    └── MarshmallowStick (Tool)
        └── Marshmallow
            └── cook (BindableFunction)
```

Will correctly find the Marshmallow regardless of nesting depth. No changes needed for future MarshmallowStick implementation.

---

## 9. Workflow Notes

### Rojo + Studio Workflow

1. Create/modify files in filesystem
2. Rojo syncs to Studio automatically
3. For physical components: build in Studio → export as `.rbxm`
4. When Rojo pushes the `.rbxm` back, delete the duplicate in Studio

### Touch File to Force Sync

If Studio gets out of sync:
```bash
touch /path/to/file.lua
```

Rojo detects the timestamp change and re-syncs.

---

## 10. Current File Structure

```
Framework/v1/
├── default.project.json
├── wally.toml
├── .gitignore
├── Logs/
│   ├── 2025-12-25_19-08-36_session-log.md
│   ├── 2025-12-25_20-08-18_session-log.md
│   └── 2025-12-25_21-05-39_session-log.md
└── src/
    ├── Assets/
    │   ├── Dispenser/
    │   │   ├── init.meta.json
    │   │   ├── Anchor.rbxm
    │   │   ├── ReplicatedStorage/
    │   │   │   └── ModuleScript.lua
    │   │   └── ServerScriptService/
    │   │       └── Script.server.lua
    │   └── ZoneController/
    │       ├── init.meta.json
    │       ├── Zone.rbxm
    │       └── ServerScriptService/
    │           └── Script.server.lua
    ├── Templates/
    │   └── Marshmallow/
    │       ├── init.meta.json
    │       ├── Handle.rbxm              # Created in Studio
    │       ├── cook/
    │       │   └── init.meta.json
    │       └── Script.server.lua
    ├── Authentication/
    │   └── ...
    └── System/
        └── ...
```

---

## 11. Test Flow (Working)

1. Player approaches Dispenser, triggers ProximityPrompt
2. Marshmallow cloned from Templates, placed in player's Backpack
3. Player walks into ZoneController zone
4. `Touched` fires → ZoneController searches Player (including Backpack)
5. Finds Marshmallow with `cook` BindableFunction → adds to attendance
6. Every `TickRate` seconds → invokes `cook` with state table
7. Marshmallow logs cooking progress, updates `CookLevel` attribute
8. Player leaves zone → `TouchEnded` fires → touch count reaches 0
9. Marshmallow removed from attendance → cooking stops

---

## 12. Next Steps (Not Started)

1. Add distance-based heat calculation (hotter at zone center)
2. Create MarshmallowStick tool that holds the Marshmallow
3. Visual feedback for cooking (color change, particles)
4. Build out the Campfire visual asset
5. Test with multiple players/marshmallows simultaneously
